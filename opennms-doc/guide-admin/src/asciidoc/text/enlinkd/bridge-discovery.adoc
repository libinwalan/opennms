
==== Bridge Discovery

The links from the bridge forwarding table elaborations needs a deep explanation.
First of all you should consider that the transparent bridge has only local map of the network:
it acts in such a manner, if I got a frame whose source mac address is for example `0aabb11ccdd` on port 10 then I put an entry in my table for that mac address on that port so that when I got a frame with destination mac address 00aabb11ccd` I know that I have to forward it on port 10.
Transparent bridging is not loop free so if you have loops you have to enable the spanning tree protocol that will detect loops and again will put some port in a state _blocking_ to avoid loops.
To get links you need to perform some calculations that let you find the links.
We can consider that mainly we have links between a workstation or server (identified by a mac address) and links between bridges.
We call them _macLink_ and the others _bridgeLink_.
A _bridgeLink_ is a _connection_ between backbone ports.
So we have written a code that is able to identify backbone ports and then able to associate mac address to the source port on source bridge where it was originally learned.
So you have to consider the following, at the end the algorithm is able to make an association of bridge port with a set of _source mac addresses_ as it understand that they are all connected to that port.
By the nature of the algorithm it is possible that we can have this set of mac addresses associated to more then one bridgeport: this is understable especially considering that we can "miss" a device in the middle.
In this case we save set of mac addresses for all the bridge port addressing to them.
So to get links you must first of all get the backbone links between bridges, these are saved into _bridgeBridgeLink_ table.

.Supported MIBS from the Cisco-VTP MIB
[options="headers, autowidth"]
|===
| Name                            | OID                           | Description
| _vtpVersion_                    | `.1.3.6.1.4.1.9.9.46.1.1.1.0` | The version of VTP in use on the local system.
                                                                    A device will report its version capability and not any particular version in use on the device.
                                                                    If the device does not support _VTP_, the version is _none(3)_.
|===

.Supported MIBS from the MIB2-IP MIB
[options="headers, autowidth"]
|===
| Name                            | OID                           | Description
| _ipNetToMediaIfIndex_           | `.1.3.6.1.2.1.4.22.1.1`       | The interface on which this entry's equivalence is effective.
                                                                    The interface identified by a particular value of this index is the same interface as identified by the same value of _ifIndex_.
| _ipNetToMediaPhysAddress_       | `.1.3.6.1.2.1.4.22.1.2`       | The media-dependent _physical_ address.
| _ipNetToMediaNetAddress_        | `.1.3.6.1.2.1.4.22.1.3`       | The _IpAddress_ corresponding to the media-dependent _physical_ address.
| _ipNetToMediaType_              | `.1.3.6.1.2.1.4.22.1.4`       | The type of mapping. Setting this object to the value _invalid(2)_ has the effect of invalidating the corresponding entry in the _ipNetToMediaTable_.
                                                                    That is, it effectively dissasociates the interface identified with said entry from the mapping identified with said entry.
                                                                    It is an implementation-specific matter as to whether the agent removes an invalidated entry from the table.
                                                                    Accordingly, management stations must be prepared to receive tabular information from agents that corresponds to entries not currently in use.
                                                                    Proper interpretation of such entries requires examination of the relevant _ipNetToMediaType_ object.
|===

.Supported MIBS from the Bridge MIB
[options="headers, autowidth"]
|===
| Name                            | OID                           | Description
| _dot1dBaseBridgeAddress_        | `.1.3.6.1.2.1.17.1.1.0`       | The MAC address used by this bridge when it must be referred to in a unique fashion.
                                                                    It is recommended that this be the numerically smallest MAC address of all ports that belong to this bridge.
                                                                    However it is only required to be unique.
                                                                    When concatenated with _dot1dStpPriority_ a unique _BridgeIdentifier_ is formed which is used in the _Spanning Tree Protocol_.
| _dot1dBaseNumPorts_             | `.1.3.6.1.2.1.17.1.2.0`       | The number of ports controlled by this bridging entity.
| _dot1dBase.dot1dBaseType_       | `.1.3.6.1.2.1.17.1.3.0`       | Indicates what type of bridging this bridge can perform.
                                                                    If a bridge is actually performing a certain type of bridging this will be indicated by entries in the port table for the given type.
| _dot1dStpProtocolSpecification_ | `.1.3.6.1.2.1.17.2.1.0`       | An indication of what version of the Spanning Tree Protocol is being run.
                                                                    The value _decLb100(2)_ indicates the _DEC LANbridge 100 Spanning Tree protocol_.
                                                                    _IEEE 802.1d_ implementations will return _ieee8021d(3)_.
                                                                    If future versions of the _IEEE Spanning Tree Protocol_ are released that are incompatible with the current version a new value will be defined.
| _dot1dStpPriority_              | `.1.3.6.1.2.1.17.2.2.0`       | The value of the write-able portion of the _Bridge ID_, i.e., the first two octets of the (8 octet long) _Bridge ID_.
                                                                    The other (last) 6 octets of the _Bridge ID_ are given by the value of _dot1dBaseBridgeAddress_.
| _dot1dStpDesignatedRoot_        | `.1.3.6.1.2.1.17.2.5.0`       | The bridge identifier of the root of the spanning tree as determined by the _Spanning Tree Protocol_ as executed by this node.
                                                                    This value is used as the _Root Identifier_ parameter in all configuration _Bridge PDUs_ originated by this node.
| _dot1dStpRootCost_              | `.1.3.6.1.2.1.17.2.6.0`       | The cost of the path to the root as seen from this bridge.
| _dot1dStpRootPort_              | `.1.3.6.1.2.1.17.2.7.0`       | The port number of the port which offers the lowest cost path from this bridge to the root bridge.
|===

[source, sql]
----
opennms=# opennms=# \d bridgebridgelink
Table "public.bridgebridgelink"
Column | Type | Modifiers
--------------------------------------------------------------------------------------------------------
id | integer | not null default nextval('opennmsnxtid'::regclass)
nodeid | integer | not null
bridgeport | integer |
bridgeportifindex | integer |
bridgeportifname | character varying(32) |
vlan | integer |
designatednodeid | integer | not null
designatedbridgeport | integer |
designatedbridgeportifindex | integer |
designatedbridgeportifname | character varying(32) |
designatedvlan | integer |
bridgebridgelinkcreatetime | timestamp with time zone | not null
bridgebridgelinklastpolltime | timestamp with time zone | not null
Indexes:
"pk_bridgebridgelink" PRIMARY KEY, btree (id)
"bridgebridgelink_lastpoll_idx" btree (bridgebridgelinklastpolltime)
"bridgebridgelink_nodeid_idx" btree (nodeid)
"bridgebridgelink_pk_idx" btree (nodeid, bridgeport)
Foreign-key constraints:
"fk_bridgebridgelink_designatednodeid" FOREIGN KEY (designatednodeid) REFERENCES node(nodeid) ON DELETE CASCADE
"fk_bridgebridgelink_nodeid" FOREIGN KEY (nodeid) REFERENCES node(nodeid) ON DELETE CASCADE
----

These links are saved as one direction link from node to designated node.
the quety here is simply:

[source, sql]
----
select * from bridgebridgelink;
----

Once you got the backbone links you must get the mac links. This are saved in the database table bridgeMacLink

[source, sql]
----
opennms=# \d bridgeMacLink
Table "public.bridgemaclink"
Column | Type | Modifiers
-----------------------------------------------------------------------------------------------------
id | integer | not null default nextval('opennmsnxtid'::regclass)
nodeid | integer | not null
bridgeport | integer | not null
bridgeportifindex | integer |
bridgeportifname | character varying(32) |
vlan | integer |
macaddress | character varying(12) | not null
bridgemaclinkcreatetime | timestamp with time zone | not null
bridgemaclinklastpolltime | timestamp with time zone | not null
Indexes:
"pk_bridgemaclink" PRIMARY KEY, btree (id)
"bridgemaclink_lastpoll_idx" btree (bridgemaclinklastpolltime)
"bridgemaclink_nodeid_idx" btree (nodeid)
"bridgemaclink_pk_idx1" btree (nodeid, bridgeport)
"bridgemaclink_pk_idx2" btree (macaddress)
Foreign-key constraints:
"fk_bridgemaclink_nodeid" FOREIGN KEY (nodeid) REFERENCES node(nodeid) ON DELETE CASCADE
It is important to understand that the association is only with mac address and not with node. In openNMS we indentify node with ip address so we need to join this table with another table which holds tha ipnettomedia informations. So we have an association from bridgeport to mac address and hopefully the associated ip address, we still need to join on ipinterface to get the associated nodeid so the query should be the following
select mlink.*, ip.nodeid as targetnodeid from bridgemaclink as mlink left join ipnettomedia as ntm on mlink.macaddress = ntm.physaddress left join ipinterface ip on ip.ipaddr = ntm.netaddress;
This select is simple but this works in the assumption that there are no duplicated ip addresses and mac addresses too. This is not what happens in real network, where I found in my experience a lot of duplicated ip addresses and also mac addresses.
Here is the way in which we have the ipnettomedia table defined:
opennms=# \d ipnettomedia
Table "public.ipnettomedia"
Column | Type | Modifiers
-----------------------------------------------------------------------------------------
id | integer | not null default nextval('opennmsnxtid'::regclass)
netaddress | text | not null
physaddress | character varying(32) | not null
sourcenodeid | integer | not null
sourceifindex | integer | not null
createtime | timestamp with time zone | not null
lastpolltime | timestamp with time zone | not null
Indexes:
"pk_ipnettomedia" PRIMARY KEY, btree (id)
"ipnettomedia_lastpoll_idx" btree (lastpolltime)
"ipnettomedia_nodeid_idx" btree (sourcenodeid)
"ipnettomedia_pk_idx" btree (netaddress, physaddress)
Foreign-key constraints:
"fk_ipnettomedia_sourcenodeid" FOREIGN KEY (sourcenodeid) REFERENCES node(nodeid) ON DELETE CASCADE
----

Duplicated ipaddress or duplicated mac address will lead with this query to fake links.
