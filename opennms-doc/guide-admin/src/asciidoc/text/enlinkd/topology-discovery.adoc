
=== Topology Discovery

_Enhanced Linkd_ (enlinkd) has been designed to get a snapshot of the neighbors from the device point of view.
Essentially it asks each device the following question: "What is the network topology from your point of view".
From this point of view this will only provide local topology discovery features.
It does not attempt to discover global topology or doing any correlation with the data coming from other nodes.

Actually it supports linkd discovery for the following protocols:

* Layer 2 protocols link:https://en.wikipedia.org/wiki/Link_Layer_Discovery_Protocol[Link Layer Discovery Protocol] (LLDP), link:https://en.wikipedia.org/wiki/Cisco_Discovery_Protocol[Cisco Discovery Protocol] (CDP) and transparent bridge discovery
* Layer 3 protocols link:https://en.wikipedia.org/wiki/Open_Shortest_Path_First[Open Shortest Path First] (OSPF) and link:https://en.wikipedia.org/wiki/IS-IS[Intermediate System to Intermediate System] (IS-IS)

The general strategy it does its work is walk SNMP data and persist data into the OpenNMS database table.
There is a 1:1 relation between SNMP scalars and tables with database tables.
We adapt a strictly walk and persist strategy.

==== LLDP Discovery

==== CDP Discovery

==== Bridge Discovery

The links from the bridge forwarding table elaborations needs a deep explanation.
First of all you should consider that the transparent bridge has only local map of the network:
it acts in such a manner, if I got a frame whose sorce mac address is for example '00aabb11ccdd' on port 10 then I put an entry in my table for that mac address on that port so that when I got a frame with destination mac address '00aabb11ccdd' I know that I have to forward it on port 10.
Transparent bridging is not loop free so if you have loops you have to enable the spanning tree protocol that will detect loops and again will put some port in a state "blocking" to avoid loops.
There is no link state algorithm like OSPF. So to get links you need to perform some calculations that let you find the links.
We can consider that mainly we have links between a workstation or server (identified by a mac address) and links beetween bridges.
We call them macLink and the others bridgeLink. A bridgeLink is a "connection" between backbone ports.
So we have written a code that is able to identify backbone ports and then able to associate mac address to the source port on source bridge where it was originaly learned.
So you have to consider the following, at the end the algorithm is able to make an association of bridge port with a set of "source mac addresses" as it understand that they are all connected to that port. By the nature of the algorithm it is possible that we can have this set of mac addresses associated to more then one bridgeport: this is understable especially considering that we can "miss" a device in the middle. In this case we save set of mac addresses for all the bridge port addressing to them.
So to get links you must first of all get the backbone links between bridges, these are saved into bridgeBridgeLink table.

[source, sql]
----
opennms=# opennms=# \d bridgebridgelink
Table "public.bridgebridgelink"
Column | Type | Modifiers
--------------------------------------------------------------------------------------------------------
id | integer | not null default nextval('opennmsnxtid'::regclass)
nodeid | integer | not null
bridgeport | integer |
bridgeportifindex | integer |
bridgeportifname | character varying(32) |
vlan | integer |
designatednodeid | integer | not null
designatedbridgeport | integer |
designatedbridgeportifindex | integer |
designatedbridgeportifname | character varying(32) |
designatedvlan | integer |
bridgebridgelinkcreatetime | timestamp with time zone | not null
bridgebridgelinklastpolltime | timestamp with time zone | not null
Indexes:
"pk_bridgebridgelink" PRIMARY KEY, btree (id)
"bridgebridgelink_lastpoll_idx" btree (bridgebridgelinklastpolltime)
"bridgebridgelink_nodeid_idx" btree (nodeid)
"bridgebridgelink_pk_idx" btree (nodeid, bridgeport)
Foreign-key constraints:
"fk_bridgebridgelink_designatednodeid" FOREIGN KEY (designatednodeid) REFERENCES node(nodeid) ON DELETE CASCADE
"fk_bridgebridgelink_nodeid" FOREIGN KEY (nodeid) REFERENCES node(nodeid) ON DELETE CASCADE
These links are saved as one direction link from node to designated node.
the quety here is simply:
select * from bridgebridgelink;
Once you got the backbone links you must get the mac links. This are saved in the database table bridgeMacLink
opennms=# \d bridgeMacLink
Table "public.bridgemaclink"
Column | Type | Modifiers
-----------------------------------------------------------------------------------------------------
id | integer | not null default nextval('opennmsnxtid'::regclass)
nodeid | integer | not null
bridgeport | integer | not null
bridgeportifindex | integer |
bridgeportifname | character varying(32) |
vlan | integer |
macaddress | character varying(12) | not null
bridgemaclinkcreatetime | timestamp with time zone | not null
bridgemaclinklastpolltime | timestamp with time zone | not null
Indexes:
"pk_bridgemaclink" PRIMARY KEY, btree (id)
"bridgemaclink_lastpoll_idx" btree (bridgemaclinklastpolltime)
"bridgemaclink_nodeid_idx" btree (nodeid)
"bridgemaclink_pk_idx1" btree (nodeid, bridgeport)
"bridgemaclink_pk_idx2" btree (macaddress)
Foreign-key constraints:
"fk_bridgemaclink_nodeid" FOREIGN KEY (nodeid) REFERENCES node(nodeid) ON DELETE CASCADE
It is important to understand that the association is only with mac address and not with node. In openNMS we indentify node with ip address so we need to join this table with another table which holds tha ipnettomedia informations. So we have an association from bridgeport to mac address and hopefully the associated ip address, we still need to join on ipinterface to get the associated nodeid so the query should be the following
select mlink.*, ip.nodeid as targetnodeid from bridgemaclink as mlink left join ipnettomedia as ntm on mlink.macaddress = ntm.physaddress left join ipinterface ip on ip.ipaddr = ntm.netaddress;
This select is simple but this works in the assumption that there are no duplicated ip addresses and mac addresses too. This is not what happens in real network, where I found in my experience a lot of duplicated ip addresses and also mac addresses.
Here is the way in which we have the ipnettomedia table defined:
opennms=# \d ipnettomedia
Table "public.ipnettomedia"
Column | Type | Modifiers
-----------------------------------------------------------------------------------------
id | integer | not null default nextval('opennmsnxtid'::regclass)
netaddress | text | not null
physaddress | character varying(32) | not null
sourcenodeid | integer | not null
sourceifindex | integer | not null
createtime | timestamp with time zone | not null
lastpolltime | timestamp with time zone | not null
Indexes:
"pk_ipnettomedia" PRIMARY KEY, btree (id)
"ipnettomedia_lastpoll_idx" btree (lastpolltime)
"ipnettomedia_nodeid_idx" btree (sourcenodeid)
"ipnettomedia_pk_idx" btree (netaddress, physaddress)
----

[source, sql]
----
Foreign-key constraints:
"fk_ipnettomedia_sourcenodeid" FOREIGN KEY (sourcenodeid) REFERENCES node(nodeid) ON DELETE CASCADE
----

Duplicated ipaddress or duplicated mac address will lead with this query to fake links.

==== OSPF Discovery

The relevant MIB for OSPF topology are OSPF-MIB and OSPF-TRAP-MIB, supported by junos, and usually available with junos mib distribution under standardMib as mib-ospf2mib.txt and mib-ospf2trap.txt.
In this mib are defined the relevant object to be used to find ospf links.
In particular consider that

* The Router ID, in OSPF, has the same format as an IP Address,
* but identifies the router independent of its IP Address.

Also all the interfaces are identified by the ip address.
The Ospf links comes from the router ospfNbrTable defined in OSPF-MIB and this table is in practice persisted in ospflink table:

[source, sql]
----
opennms=# \d ospflink
Table "public.ospflink"
Column | Type | Modifiers
---------------------------------------------------------------------------------------------------
id | integer | not null default nextval('opennmsnxtid'::regclass)
nodeid | integer | not null
ospfipaddr | character varying(16) |
ospfipmask | character varying(16) |
ospfaddresslessindex | integer |
ospfifindex | integer |
ospfremrouterid | character varying(16) | not null
ospfremipaddr | character varying(16) | not null
ospfremaddresslessindex | integer | not null
ospflinkcreatetime | timestamp with time zone | not null
ospflinklastpolltime | timestamp with time zone | not null
----

You see that the linked router is identified by ospfremrouterid and the corresponding interface by ospfremipaddr/ospfremaddresslessindex.
If you consider the following link routerA:10.10.10.1/30 <------------->10.10.10.2/30:routerB you have to consider that you have two entries in ospflink, one corresponding to a walk of ospfNbrTable on routerA and one corresponding to ospfnbrTable routerB.
Also you can consider that the ospfifindex is available only for routerA.
How to get the full link informations ie also the ospfifindex of the remipaddress, simply joining ospflink with itself:

[source, sql]
----
select * from ospflink a left join ospflink b on a.ospfipaddr = b.ospfremipaddr;
----

consider that you usually have two links...let me say..from A to B and from B to A.
This in consideration that both nodes are provided to opennms and also that both support OSPF-MIB and finally that both have been walked at least once.
To check the status of Ospf link usually you can check the linkUp/LinkDown traps defined in IF-MIB (mib-rfc2863a.txt) that both carry in varbind the ifindex.
To have a better definition of the status of the ospf link you can check the OSPF-TRAP-MIB, in particular you can also check:

[source]
----
ospfIfStateChange NOTIFICATION-TYPE
OBJECTS
{ ospfRouterId, -- The originator of the trap ospfIfIpAddress, ospfAddressLessIf, ospfIfState -- The new state }
STATUS current
DESCRIPTION
"An ospfIfStateChange trap signifies that there
has been a change in the state of a non-virtual
OSPF interface. This trap should be generated
when the interface state regresses (e.g., goes
from Dr to Down) or progresses to a terminal
state (i.e., Point-to-Point, DR Other, Dr, or
Backup)."
ospfNbrStateChange NOTIFICATION-TYPE
OBJECTS
{ ospfRouterId, -- The originator of the trap ospfNbrIpAddr, ospfNbrAddressLessIndex, ospfNbrRtrId, ospfNbrState -- The new state }
STATUS current
DESCRIPTION
"An ospfNbrStateChange trap signifies that
there has been a change in the state of a non-
virtual OSPF neighbor. This trap should be
generated when the neighbor state regresses
(e.g., goes from Attempt or Full to 1-Way or
Down) or progresses to a terminal state (e.g.,
2-Way or Full). When an neighbor transitions
from or to Full on non-broadcast multi-access
and broadcast networks, the trap should be gen-
erated by the designated router. A designated
router transitioning to Down will be noted by
ospfIfStateChange."
::=
{ ospfTraps 2 }
----

both traps use the ipaddress to identify the interface.
Finally let me try to consider the following use case: routerA is provided in opennms, supports OSPF-MIB
Any of this:

. routerB is not provided in opennms
. routerB does not support OSPF-MIB
. routerB has not been walked by enhanced linkd.

In this case you got only one link and no ifindex association to routerB.
If routerB is provided into opennms and does not support OSPF you can in any case got the ifindex accessing the ipinterface table.
So another option could be:

[source, sql]
----
select * from ospflink a left join ipinterface b on b.ipaddr = a.ospfremipaddr;
----

==== IS-IS Discovery

IS-IS links are found walking the isisISAdjTable that is defined in ISIS-MIB, (mib-rfc4444.txt) in standard mibs under Juniper junos supported Mib tree.
In this table you got the information you need to find the Adjency Intermediate System.
The information about Is-Is is stored into two tables: isisElement and isisLink.
isisElement contains the ISISSysID a unique identifier of the "Intermediate System" (that is the name for the Router in iso protocols).
Each entry in this table (snmp) represents a link, let me say, a one direction link from the Intermediate system that is queried to the Adj Intermediate systems running IS-IS and "let me say" peering with the source router.
If two routers let me say IS-A and IS-B support ISIS-MIB you will find two entries in opennms, one that is the direction from IS-A to IS-B get walking IS-A adjTable and the way back from IS-B to IS-A.
get walking IS-B adjTable
Here you find the definition of the tables in our database:

[source, sql]
----
opennms=# \d isiselement
Table "public.isiselement"
Column | Type | Modifiers
------------------------------------------------------------------------------------------------
id | integer | not null default nextval('opennmsnxtid'::regclass)
nodeid | integer | not null
isissysid | character varying(32) | not null
isissysadminstate | integer | not null
isisnodecreatetime | timestamp with time zone | not null
isisnodelastpolltime | timestamp with time zone | not null
Indexes:
"pk_isiselement" PRIMARY KEY, btree (id)
"isiselement_nodeid_idx" btree (nodeid)
"isiselement_sysid_idx" btree (isissysid)
Foreign-key constraints:
"fk_isiselement_nodeid" FOREIGN KEY (nodeid) REFERENCES node(nodeid) ON DELETE CASCADE
and
opennms=# \d isislink
Table "public.isislink"
Column | Type | Modifiers
------------------------------------------------------------------------------------------------------
id | integer | not null default nextval('opennmsnxtid'::regclass)
nodeid | integer | not null
isiscircindex | integer | not null
isisisadjindex | integer | not null
isiscircifindex | integer |
isiscircadminstate | integer |
isisisadjstate | integer | not null
isisisadjneighsnpaaddress | character varying(80) | not null
isisisadjneighsysyype | integer | not null
isisisadjneighsysid | character varying(32) | not null
isisisadjnbrextendedcircid | integer | not null
isislinkcreatetime | timestamp with time zone | not null
isislinklastpolltime | timestamp with time zone | not null
Indexes:
"pk_isislink" PRIMARY KEY, btree (id)
"isislink_lastpoll_idx" btree (isislinklastpolltime)
"isislink_nodeid_idx" btree (nodeid)
"isislink_pk_idx" btree (nodeid, isiscircindex, isisisadjindex)
----

Foreign-key constraints:
[source, sql]
----
"fk_isislink_nodeid" FOREIGN KEY (nodeid) REFERENCES node(nodeid) ON DELETE CASCADE
----

As usual in the case in which both nodes belong to opennms and have persisted data regarding IS-IS the links can be found using the join of isislink with herselves but with a more join to get the nodeid, In particular the identification of the link is made using the isisISAdjNeighSysID and also using the following index: isisISAdjIndex that is share across the Adjencies.
Let's start with the following query:

[source, sql]
----
select * from isislink l1 left join isiselement e on l1.isisisadjneighsysid = e.isissysid;
----

In this way you are able to get the "nodeid" of the Adjency Intermediate System, how to get the other link....just joining once more on isislink:

[source, sql]
----
select * from isislink l1 left join isiselement e on l1.isisisadjneighsysid = e.isissysid left join isislink l2 on e.nodeid=l2.nodeid where l1.isisisadjindex = l2.isisisadjindex;
----

The only other information needed is that in the case of isislink we have the ifIndex stored in the isiscircifindex row.
With the previous query you are able to get both nodeid and ifindex for the source node and the Adj node.
Another way to find links is considering the following field: isisisadjneighsnpaaddress this is the "mac address" of the received frame.
IS-IS is a layer2 encapsulated protocol. So this field represents the source address of the received IS-IS frame and identify the interface that has send the IS-IS datagram.
So another option could be the following to get links:

[source, sql]
----
select * from isislink l1 left join snmpinterface s1 on l1.isisisadjneighsnpaaddress = s1.snmpphysaddr
----

Let's go to how is possible to monitor links....well, in each entry (row) of the isislink table you have the isiscircifindex and this will give you the ability to set the link state using the snmp_link_up/snmp_link_down traps defined in IP-MIB.
More into the ISIS-MIB there are several traps defined that are very useful to monitor IS-IS protocol. One could also be used to get the Adj status and then the status of the link:

[source]
----
isisAdjacencyChange NOTIFICATION-TYPE
OBJECTS
{ isisNotificationSysLevelIndex, isisNotificationCircIfIndex, isisPduLspId, isisAdjState }
STATUS current
DESCRIPTION
"A notification sent when an adjacency changes
state, entering or leaving state up.
The first 6 bytes of the isisPduLspId are the
SystemID of the adjacent IS.
The isisAdjState is the new state of the adjacency."
::=
{ isisNotifications 17 }
In the varbind you also get isisNotificationCircIfIndex, this is aved in isisLink table so you should immediatly update the information you got from the trap into the database/opennms system.
----

==== Configuring enlinkd

==== User checklist / Troubleshooting
